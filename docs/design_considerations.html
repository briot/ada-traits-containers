
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Design considerations &#8212; Generic Ada Library (GAL) 0.1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Graph algorithms" href="graph_algorithms.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-considerations">
<h1>Design considerations<a class="headerlink" href="#design-considerations" title="Permalink to this headline">¶</a></h1>
<p>During the design of this library, there were quite a number of design
decisions that were taken and might not be immediately obvious.</p>
<p>This chapter documents these decisions, and perhaps the limitations they bring,
or the flexibility they offer.</p>
<p>This chapter is really about the internal design of the library, and can be
skipped if you are only interested in using the final product.</p>
<div class="section" id="nested-generics">
<h2>Nested generics<a class="headerlink" href="#nested-generics" title="Permalink to this headline">¶</a></h2>
<p>As we have seen, this library makes extensive use of generics, and generics
that receive other generics as parameters. This makes the library sometimes
harder to instantiate than one might like.</p>
<p>Let’s take an example. A we saw, a lot of graph algorithms need to store
information in the vertex, like a color to know whether they were already
visited or not. These properties are stored in what we call a property
map. So one approach would be to take both a graph and a property map,
each defined independently of each other:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kd">type</span> <span class="kt">Graph</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">type</span> <span class="kt">Vertex</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
<span class="kd">package</span> <span class="nc">Graph_Traits</span> <span class="kr">is</span>
<span class="kr">end</span> <span class="nf">Graph_Traits</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kd">type</span> <span class="kt">Key</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">type</span> <span class="kt">Value</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kn">with</span> <span class="nn">function</span> <span class="n">Get</span> <span class="p">(</span><span class="n">G</span> <span class="p">:</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Graph</span><span class="p">;</span> <span class="n">K</span> <span class="p">:</span> <span class="n">Key</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Value</span><span class="p">;</span>
<span class="kd">package</span> <span class="nc">Property_Maps</span> <span class="kr">is</span>
<span class="kr">end</span> <span class="nf">Property_Maps</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Property_Maps</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">procedure</span> <span class="nf">Some_Algo</span><span class="p">;</span>
</pre></div>
</div>
<p>Such a description however is useless to us. It is not possible to specify that
the <cite>Color_Maps</cite> is applied to a <cite>Graphs.Vertex</cite> and stores <cite>Color</cite>. So we
cannot in effect use the <cite>Maps</cite> in our algorithm.</p>
<p>What we really would like is a partial constraint applied to the formal
parameters, as in the following invalid Ada code:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Property_Maps</span>
      <span class="p">(</span><span class="n">Graphs</span><span class="p">,</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Color</span><span class="p">,</span> <span class="p">&lt;&gt;);</span>   <span class="c1">--  Invalid Ada</span>
<span class="kd">procedure</span> <span class="nf">Some_Algo</span><span class="p">;</span>
</pre></div>
</div>
<p>where the exact implementation of <cite>Get</cite> is unspecified, but we still want to
associate a <cite>Color</cite> with a <cite>Vertex</cite>.</p>
<p>Instead we have to use a slightly more complex definition for the property
maps, which helps us define parts of the parameter, and leave some others
unspecified:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kd">type</span> <span class="kt">Graph</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">type</span> <span class="kt">Key</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">type</span> <span class="kt">Value</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
<span class="kd">package</span> <span class="nc">Property_Maps</span> <span class="kr">is</span>
   <span class="kd">generic</span>
      <span class="kn">with</span> <span class="nn">function</span> <span class="n">Get</span> <span class="p">(</span><span class="n">G</span> <span class="p">:</span> <span class="n">Graph</span><span class="p">;</span> <span class="n">K</span> <span class="p">:</span> <span class="n">Key</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Value</span><span class="p">;</span>
   <span class="kd">package</span> <span class="nc">Map</span> <span class="kr">is</span>
   <span class="kr">end</span> <span class="nf">Map</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Property_Maps</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kd">type</span> <span class="kt">Graph</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">type</span> <span class="kt">Vertex</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
<span class="kd">package</span> <span class="nc">Graph_Traits</span> <span class="kr">is</span>
   <span class="kd">package</span> <span class="nc">Color_Maps</span> <span class="kr">is new</span> <span class="nc">Property_Maps</span> <span class="p">(</span>Graph<span class="p">,</span> Vertex<span class="p">,</span> Color<span class="p">);</span>
<span class="kr">end</span> <span class="nf">Graph_Traits</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Maps</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">procedure</span> <span class="nf">Some_Algo</span><span class="p">;</span>
</pre></div>
</div>
<p>At this point, the compiler knows that Maps will be a pakage that provides a
<cite>Get</cite> function, that maps our <cite>Vertex</cite> to a <cite>Color</cite> appropriately.  This comes
at the cost of one extra level of instantiation (the <cite>Color_Maps</cite> in the
<cite>Graph_Traits</cite> package).</p>
</div>
<div class="section" id="pre-and-post-conditions">
<h2>Pre and post conditions<a class="headerlink" href="#pre-and-post-conditions" title="Permalink to this headline">¶</a></h2>
<p>This library is meant to be (at least for a subset) usable for SPARK users that
want to prove their code. To do so, the API needs to set pre and post conditions
on the relevant subprograms.</p>
<p>One of the difficulties, however, is that some of the preconditions need to be
computed. For instance, a tree layout algorithm would not work on a graph with
cycle. As it happens, there is an algorithm (based on depth-first-search) to
compute whether a graph has cycles.</p>
<p>This is however a generic algorithm, which needs to be instantiated with a
description of what a graph, vertex and edge are (the <cite>Graph_Traits</cite>), as
well as a <cite>Color_Property_Map</cite>. So we have the following:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">function</span> <span class="nf">Is_Acyclic</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Booolean</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">procedure</span> <span class="nf">Tree_Layout</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">);</span>
</pre></div>
</div>
<p>However, as it is we cannot use Is_Acyclic in a precondition, since we have
no instance of it.</p>
<p>The only solution therefore is to pass the instance of Is_Acyclic directly
as a formal parameter. The following invalid code would be interesting:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">function</span> <span class="nf">Is_Acyclic</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>

<span class="c1">--  Invalid Ada</span>
<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">function</span> <span class="n">Acyclic</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Is_Acylic</span> <span class="p">(</span><span class="n">Graphs</span><span class="p">,</span> <span class="p">&lt;&gt;);</span>
<span class="kd">procedure</span> <span class="nf">Tree_Layout</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span>
   <span class="kn">with</span> <span class="nn">Pre</span> <span class="p">=&gt;</span> <span class="n">Acyclic</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<p>This is however invalid for two reasons:</p>
<blockquote>
<div><ul>
<li><p>As we saw before, we cannot use partial instantiation, so we need to also
have an instance of <cite>Color_Property_Maps</cite> as a parameter:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">function</span> <span class="nf">Is_Acyclic</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>

<span class="c1">--  Invalid Ada</span>
<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">function</span> <span class="n">Acyclic</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Is_Acylic</span> <span class="p">(</span><span class="n">Graphs</span><span class="p">,</span> <span class="n">Maps</span><span class="p">);</span>
<span class="kd">procedure</span> <span class="nf">Tree_Layout</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span>
   <span class="kn">with</span> <span class="nn">Pre</span> <span class="p">=&gt;</span> <span class="n">Acyclic</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>In fact, as opposed to formal packages, Ada does not let us indicate that a
formal parameter is an instance of a specific generic subprogram.</p>
<p>The simpler approach would be to let any value for <cite>Acyclic</cite>, as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">function</span> <span class="n">Acyclic</span> <span class="p">(</span><span class="n">G</span> <span class="p">:</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Graph</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
<span class="kd">procedure</span> <span class="nf">Tree_Layout</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span>
   <span class="kn">with</span> <span class="nn">Pre</span> <span class="p">=&gt;</span> <span class="n">Acyclic</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<p>The main drawback here, though, is that the user could pass anything
function as an actual parameter, so the algorithm does not know for a fact
that it did receive an acyclic graph. So a better solution is to use a
generic package instead:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
<span class="kd">package</span> <span class="kr">Is</span><span class="mi">_</span><span class="n">Acyclic</span> <span class="kr">is</span>
   <span class="kd">function</span> <span class="nf">Acyclic</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Is_Acyclic</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Graphs</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Graph_Traits</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Maps</span> <span class="kr">is</span>
      <span class="kr">new</span> <span class="n">Graphs</span><span class="p">.</span><span class="n">Color_Property_Maps</span><span class="p">.</span><span class="n">Exterior</span> <span class="p">(&lt;&gt;);</span>
   <span class="kn">with</span> <span class="nn">package</span> <span class="n">Acyclic</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Is_Acylic</span> <span class="p">(</span><span class="n">Graphs</span><span class="p">,</span> <span class="n">Maps</span><span class="p">);</span>
<span class="kd">procedure</span> <span class="nf">Tree_Layout</span> <span class="p">(</span><span class="nv">G</span> <span class="p">: </span><span class="nv">Graphs</span><span class="p">.</span><span class="nv">Graph</span><span class="p">)</span>
   <span class="kn">with</span> <span class="nn">Pre</span> <span class="p">=&gt;</span> <span class="n">Acyclic</span><span class="p">.</span><span class="n">Acyclic</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<p>Since this all makes the instantiation of <cite>Tree_Layout</cite> harder, even for
users that do not need the preconditions because they do not run them
or prove their code. So the final idea is to have two versions of
<cite>Tree_Layout</cite>: one without the preconditions, as we saw in the first
example in this section, and one with the preconditions as we just saw,
which instantiates and run the first version.</p>
<p>That way, we have no code duplication, and yet have full preconditions
for users who need them.</p>
</li>
</ul>
</div></blockquote>
<p>The use of these containers in the context of SPARK imposes a minor changes
compared to the API used for the standard Ada containers: we now need to
pass the container explicitly in the cursor operations like <cite>Next</cite> and
<cite>Has_Element</cite>, whereas these are not needed for standard Ada containers.
This is so that the implementation does not need to store a pointer to the
container inside the cursor, which could be unsafe.</p>
<p>In practice, this makes the implementation cleaner and even faster since
the cursor are lighter weight.</p>
</div>
<div class="section" id="assertion-policy">
<h2>Assertion policy<a class="headerlink" href="#assertion-policy" title="Permalink to this headline">¶</a></h2>
<p>This library is intended for both Ada and SPARK users. Some of the subprograms
need to perform some validity checks on their parameters. For instance, a
function that <cite>Get</cite> the n-th element of a vector needs to check that <cite>n</cite> is
a valid index.</p>
<p>This check is part of the preconditions for <cite>Get</cite>. This is needed to prove the
use of the containers for SPARK programs.</p>
<p>Ada applications, though, might not be compiled with <cite>-gnata</cite>, and therefore
would not run the assertions. This means we need to duplicate the same check
in the body of <cite>Get</cite>.</p>
<p>This is not elegant, since it results in duplication of the code (and thus
will be hard to keep synchronized), and will result in duplicate checks at
runtime for applications compiled with <cite>-gnata</cite>.</p>
<p>Instead, our approach is to add an <cite>Assertion_Policy</cite> in all packages:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span> <span class="cp">Assertion_Policy</span> <span class="p">(</span><span class="n">Pre</span> <span class="p">=&gt;</span> <span class="n">Suppressible</span><span class="p">);</span>
<span class="kr">pragma</span> <span class="cp">Assertion_Policy</span> <span class="p">(</span><span class="n">Post</span> <span class="p">=&gt;</span> <span class="n">Ignore</span><span class="p">);</span>
<span class="kr">pragma</span> <span class="cp">Assertion_Policy</span> <span class="p">(</span><span class="n">Ghost</span> <span class="p">=&gt;</span> <span class="n">Suppressible</span><span class="p">);</span>
</pre></div>
</div>
<p>The effect is that the code for the preconditions will always be run,
no matter whether the application was compiled with <cite>-gnata</cite> or not.
We can therefore remove the explicit checks in the body of the
subprograms, and rely on those checks already written for the
preconditions.</p>
<p>Yes, since we use <cite>Suppressible</cite> as the policy, if the user wants
maximum performance at the cost of safety, they can use <cite>-gnatp</cite> on
the command line, which will also suppress these checks.</p>
<p>The postconditions are only needed for SPARK users to prove the use of
the containers, but we never need to run them. So we systematically
disable post-conditions, whether we compile with <cite>-gnata</cite> or not.</p>
</div>
<div class="section" id="default-values">
<h2>Default values<a class="headerlink" href="#default-values" title="Permalink to this headline">¶</a></h2>
<p>In Ada, it is possible to provide default values for formal subprogram
parameter in generics, as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Bar</span><span class="p">;</span>

<span class="kd">generic</span>
   <span class="kn">with</span> <span class="nn">procedure</span> <span class="n">Foo</span> <span class="kr">is</span> <span class="n">Bar</span><span class="p">;</span>
<span class="kd">package</span> <span class="nc">Pkg</span> <span class="kr">is</span>
<span class="kr">end</span> <span class="nf">Pkg</span><span class="p">;</span>
</pre></div>
</div>
<p>Unfortunately, the same doesn’t exist for formal package parameters, which
makes the instantiation of our various packages more difficult for the end
user. For instance, a number of packages that need memory allocations take
a <cite>Storage_Pool</cite> package to control how the allocations are performed.
Since we cannot set a default value for these, the user will always have
to specify <cite>GAL.Global_Pool</cite> explicitly.</p>
<p>We could also simplify the library a code a bit if the default value for
formal subprograms could be defined as an expression function, rather than
be the name of an explicit subprogram, as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">generic</span>
   <span class="kd">type</span> <span class="kt">Element</span> <span class="kr">is</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kn">with</span> <span class="nn">function</span> <span class="n">Copy</span> <span class="p">(</span><span class="n">E</span> <span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Element</span> <span class="kr">is</span> <span class="p">(</span><span class="n">E</span><span class="p">);</span>
<span class="kd">package</span> <span class="nc">Pkg</span> <span class="kr">is</span>
<span class="kr">end</span> <span class="nf">Pkg</span><span class="p">;</span>
</pre></div>
</div>
<p>and we do not have to write an <cite>Identity</cite> function as done in several
places in this library.</p>
</div>
<div class="section" id="tasking">
<h2>Tasking<a class="headerlink" href="#tasking" title="Permalink to this headline">¶</a></h2>
<p>Currently, the containers are not thread safe.</p>
<p>There are various ideas on the subject though:</p>
<blockquote>
<div><ul class="simple">
<li><p>a container that is written to from a single task, should be
safe to read from multiple tasks. This is not the case with the
standard Ada containers, since even in “read-only” mode they
still modify their tampering flags.</p></li>
<li><p>we will likely introduce a new <cite>Tasking_Policy</cite> package to help
control locking of the data structure: the default implementation
would do nothing, providing maximum efficiency, but other
implementation could use locks implemented in different ways.</p></li>
<li><p>Likewise, we could use atomic counters for reference-counted types,
and through a policy use standard integers if task-safety is not
an issue.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="tagged-types">
<h2>Tagged types<a class="headerlink" href="#tagged-types" title="Permalink to this headline">¶</a></h2>
<p>For the convenience of using the dot-notation for calling primitive operations,
we are making all containers tagged types.</p>
<p>However, they are not meant to be subclassed, and thus most operations are
class-wide. This provides maximum efficient (no dynamic dispatching), and
matches what is done in the C++ STL (no virtual methods).</p>
<p>The cursors themselves are not tagged. All cursor operations take both the
container and the cursor in parameter (to support bounded containers), and
thus the container is used in the dot-notation call (Self.Has_Element (Pos)).</p>
<p>One other advantage to tagged types is that this forces the instances to
be passed by reference, and thus limits the number of implicit copies
done when passing a container as a parameter to a subprogram.
They do not avoid copies when a function returns a container though.</p>
<p>Implementation Note: currently, the Iterable aspect requires primitive
operations, which make it slow. It should be enhanced to accept class-wide
operations instead, which would also remove a number of primitive operations
on the container types.</p>
</div>
<div class="section" id="controlled-types">
<h2>Controlled types<a class="headerlink" href="#controlled-types" title="Permalink to this headline">¶</a></h2>
<p>All standard Ada containers are controlled types. This is in general more
convenient for the user, but is not compatible with SPARK.</p>
<p>In this library, we do not force containers to be controlled. Instead, a
generic formal parameter <cite>Base_Type</cite> is often provided to let users
decide whether to use controlled types (with automatic copy and clear
operations for instance), or limited types (which prevent the assignment
iterator to avoid aliasing issues).</p>
</div>
<div class="section" id="storage-pools">
<h2>Storage pools<a class="headerlink" href="#storage-pools" title="Permalink to this headline">¶</a></h2>
<p>ome packages need to perform memory allocation. In all such cases, we declare
a formal generic package that provides the storage pools to use, so that users
have ultimate control over memory allocation (for instance, the nodes packages
themselves control how many allocations are taking place, and the storage pools
control how they are actually performed).</p>
<p>Rather than pass a single object of type access to Root_Storage_Pool’Class, we
pass both a type for the storage pool, and an object access to that type. This
is to avoid dynamic dispatching when calling the pool, since in some contexts
like libadalang, with highly optimized pools, it has been shown that the cost
of dispatching might become significant.</p>
<p>The drawback is that a formal package parameter cannot have a default value
(nor can a type, of course), so a user systematically has to provide a value.
But this is only when using the low-level generic packages. When using the
higher-level packages, they still simply take an Element_Type, and the
storage_pool is always the default global pool.</p>
<p>Example of use for custom pools:</p>
<blockquote>
<div><ul class="simple">
<li><p>more efficient pool in some contexts</p></li>
<li><p>persistent containers, by having a pool allocating a large buffer with
mmap, and then using this buffer when allocating small blocks.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="formal-representation">
<h2>Formal Representation<a class="headerlink" href="#formal-representation" title="Permalink to this headline">¶</a></h2>
<p>As this library is meant to be usable for SPARK users, annotations are provided
that describe the expected behavior of each subprogram. They are typically
written as Ada 2012 contracts. In this section, we describe the formal
representation of containers used in these annotations and explain how it can be
used to annotate user code.</p>
<blockquote>
<div><ul>
<li><p>The Notion of Models</p>
<p>The most straight forward way of annotating a subprogram dealing with
containers is by reusing the API subprograms. For example, here we have
annotated a procedure that resets every element of a vector to zero using
an Ada 2012 quantified expression and two regular functions <code class="docutils literal notranslate"><span class="pre">Last</span></code> and
<code class="docutils literal notranslate"><span class="pre">As_Element</span></code> of the vector API:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Set_All_To_Zero</span> <span class="p">(</span><span class="nv">V</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Vector</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">N</span> <span class="ow">in</span> <span class="mi">1</span> <span class="p">..</span> <span class="n">Last</span> <span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">As_Element</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>To annotate the containers API, this simple technique turned out to be
insufficient. Indeed, when annotating a procedure, it is common to refer to
the previous value of its in out parameters using the <code class="docutils literal notranslate"><span class="pre">'Old</span></code> Ada 2012
attribute. For example, this is what we could write for a procedure that
increments each element of a vector:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Increment_All</span> <span class="p">(</span><span class="nv">V</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Vector</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">N</span> <span class="ow">in</span> <span class="mi">1</span> <span class="p">..</span> <span class="n">Last</span> <span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="p">=&gt;</span>
           <span class="n">As_Element</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="n">As_Element</span> <span class="p">(</span><span class="n">V</span><span class="p">&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Unfortunately, as the <code class="docutils literal notranslate"><span class="pre">'Old</span></code> attribute introduces a copy of its argument,
it cannot be applied to expressions of a container type which may be limited.
To work-around this restriction, we introduce models for containers. Models
are actual objects which represent certain properties of the object they
model. Typically they are a higher level, simpler view of a complex
implementation. As an example, a ring buffer may be modelled by an array
representing its content in the expected order:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Ring_Buffer</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">Content</span> <span class="p">:</span> <span class="n">My_Array</span> <span class="p">(</span><span class="mi">1</span> <span class="p">..</span><span class="mi">7</span><span class="p">);</span>
   <span class="n">First</span>   <span class="p">:</span> <span class="kt">Positive</span> <span class="p">:=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Length</span>  <span class="p">:</span> <span class="kt">Natural</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">Model</span> <span class="p">(</span><span class="nv">R</span> <span class="p">: </span><span class="nv">Ring_Buffer</span><span class="p">)</span> <span class="kr">return</span> <span class="n">My_Array</span><span class="p">;</span>

<span class="kr">pragma</span> <span class="cp">Assert</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">Ring_Buffer</span><span class="p">&#39;(</span><span class="n">Content</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                   <span class="n">First</span>   <span class="p">=&gt;</span> <span class="mi">6</span><span class="p">,</span>
                                   <span class="n">Length</span> <span class="p">=&gt;</span> <span class="mi">5</span><span class="p">))</span>
               <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Models offer advantages both in terms of expressiveness, readability and
ease of use. However, they suffer from one major drawback which is
efficiency. Indeed, they typically require copies of (part of) the objects
they model and rely on a simple but often inefficient data representation.
As a consequence, models are often implemented as ghost code, which means
they can only be used in annotations so that they can be completely removed
from the final executable by the compiler:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Model</span> <span class="p">(</span><span class="nv">R</span> <span class="p">: </span><span class="nv">Ring_Buffer</span><span class="p">)</span> <span class="kr">return</span> <span class="n">My_Array</span> <span class="kn">with</span> <span class="nn">Ghost</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Functional Containers</p>
<p>To model classical imperative containers, we introduce new simpler,
mathematical like containers. They are unbounded and may contain indefinite
elements. Furthermore, to be usable in every context, they are neither
controlled nor limited. So that these containers can be used safely, we have
made them functional, that is, no primitives are provided which would allow
to modify an existing container. Instead, their API features functions
creating new containers from existing ones. As an example, functional
containers provide no <code class="docutils literal notranslate"><span class="pre">Insert</span></code> procedure but rather a function <code class="docutils literal notranslate"><span class="pre">Add</span></code>
which creates a new container with one more element than its parameter:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Add</span> <span class="p">(</span><span class="nv">C</span> <span class="p">: </span><span class="nv">Container</span><span class="p">;</span> <span class="nv">E</span> <span class="p">: </span><span class="nv">Element_Type</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Container</span><span class="p">;</span>
</pre></div>
</div>
<p>As a consequence, these containers are highly inefficient. They are also
memory consuming as the allocated memory is not reclaimed when the container
is no longer referenced. Thus, they should in general be used in ghost code
and annotations so that they can be removed from the final executable.</p>
<p>This library provides three functional containers, sequences, sets, and maps.
A sequence is no more than an ordered collection of elements. In an Ada like
manner, the user can choose the range used to index the elements:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Length</span> <span class="p">(</span><span class="nv">S</span> <span class="p">: </span><span class="nv">Sequence</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Count_Type</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">Get</span> <span class="p">(</span><span class="nv">S</span> <span class="p">: </span><span class="nv">Sequence</span><span class="p">;</span> <span class="nv">N</span> <span class="p">: </span><span class="nv">Index_Type</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Element_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>Functional sets offer standard mathematical set functionalities such as
inclusion, union, and intersection. They are neither ordered nor hashed:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Mem</span> <span class="p">(</span><span class="nv">S</span> <span class="p">: </span><span class="nv">Set</span><span class="p">;</span> <span class="nv">E</span> <span class="p">: </span><span class="nv">Element_Type</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">&quot;&lt;=&quot;</span> <span class="p">(</span><span class="nv">S1</span><span class="p">,</span> <span class="nv">S2</span> <span class="p">: </span><span class="nv">Set</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
</pre></div>
</div>
<p>Functional maps offer a dictionary between any two types of elements:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Mem</span> <span class="p">(</span><span class="nv">M</span> <span class="p">: </span><span class="nv">Map</span><span class="p">;</span> <span class="nv">K</span> <span class="p">: </span><span class="nv">Key_Type</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">Get</span> <span class="p">(</span><span class="nv">M</span> <span class="p">: </span><span class="nv">Map</span><span class="p">;</span> <span class="nv">K</span> <span class="p">: </span><span class="nv">Key_Type</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Element_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>Each functional container type supports iteration as appropriate, so that
its elements can easily be quantified over.</p>
<p>These containers can easily be used to model user defined data structures.
They were used to this end to annotate and verify a package of allocators.
In this example, an allocator featuring a free list implemented in an array
is modeled by a record containing a set of allocated resources and a
sequence of available ressources:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Status</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Available</span><span class="p">,</span> <span class="nv">Allocated</span><span class="p">);</span>
<span class="kd">type</span> <span class="kt">Cell</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">Stat</span> <span class="p">:</span> <span class="n">Status</span><span class="p">;</span>
   <span class="n">Next</span> <span class="p">:</span> <span class="n">Resource</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Allocator</span> <span class="kr">is</span> <span class="kr">array</span> <span class="p">(</span><span class="n">Valid_Resource</span><span class="p">)</span> <span class="kr">of</span> <span class="n">Cell</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Model</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">Available</span> <span class="p">:</span> <span class="n">Sequence</span><span class="p">;</span>
   <span class="n">Allocated</span> <span class="p">:</span> <span class="n">Set</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Models of Imperative Containers</p>
<p>For each container type, the library provides model functions that are used
to annotate subprograms from the API. The different models supply different
levels of abstraction of the container’s functionalities.</p>
<blockquote>
<div><ul>
<li><p>The higher level view of a container is usually the mathematical
structure of element it represents. We use a sequence for ordered
containers such as list and vectors and a mathematical map for imperative
maps. This allows us to specify the effects of a subprogram in a very high
level view, not having to consider cursors nor order of elements in a
map:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Increment_All</span> <span class="p">(</span><span class="nv">L</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">List</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">N</span> <span class="ow">in</span> <span class="mi">1</span> <span class="p">..</span> <span class="n">Length</span> <span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">=&gt;</span>
           <span class="n">Element</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span> <span class="o">=</span>  <span class="n">Element</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">L</span><span class="p">)&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="kd">procedure</span> <span class="nf">Increment_All</span> <span class="p">(</span><span class="nv">S</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Map</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span>  <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">K</span> <span class="kr">of</span> <span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)&#39;</span><span class="na">Old</span> <span class="p">=&gt;</span> <span class="n">Mem</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">K</span><span class="p">))</span>
      <span class="ow">and then</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">K</span> <span class="kr">of</span> <span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Mem</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
           <span class="ow">and then</span> <span class="n">Get</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">K</span><span class="p">)</span>  <span class="o">=</span> <span class="n">Get</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>For maps, there is a lower level model representing the underlying order
used for iteration in the map. It is a sequence of keys. We can use it if
we want to specify in <code class="docutils literal notranslate"><span class="pre">Increment_All</span></code> on maps that the order in the keys
are preserved:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Increment_All</span> <span class="p">(</span><span class="nv">S</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Map</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span> <span class="n">S_Keys</span> <span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">=</span> <span class="n">S_Keys</span> <span class="p">(</span><span class="n">S</span><span class="p">)&#39;</span><span class="na">Old</span>
     <span class="ow">and then</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">K</span> <span class="kr">of</span> <span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">=&gt;</span>
               <span class="n">Get</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">K</span><span class="p">)</span> <span class="o">=</span> <span class="n">Get</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">S</span><span class="p">)&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Finally, cursors are modeled using a functional map linking them to their
position in the container. For example, we can state that the positions
of cursors in a list are not modified by a call to <code class="docutils literal notranslate"><span class="pre">Increment_All</span></code>:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Increment_All</span> <span class="p">(</span><span class="nv">L</span> <span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">List</span><span class="p">)</span> <span class="kn">with</span>
  <span class="nn">Post</span> <span class="p">=&gt;</span> <span class="n">Positions</span> <span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">=</span> <span class="n">Positions</span> <span class="p">(</span><span class="n">L</span><span class="p">)&#39;</span><span class="na">Old</span>
     <span class="ow">and then</span> <span class="p">(</span><span class="kr">for</span> <span class="kr">all</span> <span class="n">N</span> <span class="ow">in</span> <span class="mi">1</span> <span class="p">..</span> <span class="n">Length</span> <span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">=&gt;</span>
           <span class="n">Element</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span> <span class="o">=</span>  <span class="n">Element</span> <span class="p">(</span><span class="n">Model</span> <span class="p">(</span><span class="n">L</span><span class="p">)&#39;</span><span class="na">Old</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Generic Ada Library (GAL)</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="making_of.html">The “making of” of a generic library</a></li>
<li class="toctree-l1"><a class="reference internal" href="conventions.html">Naming and Coding Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="cursors.html">Cursors and Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="elements.html">Element Traits</a></li>
<li class="toctree-l1"><a class="reference internal" href="vectors.html"><cite>Vector</cite> data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="lists.html"><cite>List</cite> data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="maps.html"><cite>Map</cite> data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphs.html"><cite>Graph</cite> data type</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph_algorithms.html">Graph algorithms</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Design considerations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#nested-generics">Nested generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pre-and-post-conditions">Pre and post conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assertion-policy">Assertion policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-values">Default values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tasking">Tasking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tagged-types">Tagged types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlled-types">Controlled types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#storage-pools">Storage pools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formal-representation">Formal Representation</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="graph_algorithms.html" title="previous chapter">Graph algorithms</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, AdaCore.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/design_considerations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>